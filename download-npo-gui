#!/usr/bin/env python
# encoding:utf-8
#
# Download videos from the Dutch `Uitzending gemist' site.
#
# http://code.arp242.net/download-npo
#
# Copyright © 2012-2015 Martin Tournoij <martin@arp242.net>
# See below for full copyright
#

from __future__ import print_function
import os, sys, time, re, traceback

# Play some import games to make it work with Python 2 & 3
if sys.version_info[0] > 2:
	import tkinter as tk
	import tkinter.ttk as ttk
	import tkinter.filedialog as filedialog
	import tkinter.messagebox as messagebox
	import queue

	try: import _thread as thread
	except ImportError: import _dummy_thread as thread
else:
	import Tkinter as tk
	import ttk
	import tkFileDialog as filedialog
	import tkMessageBox as messagebox
	import Queue as queue

	try: import thread
	except ImportError: import dummy_thread as thread

import dgemist


class GUI:
	def __init__(self, root, argv_videos=[]):
		self.queue = queue.Queue()
		self._videos = []

		self.root = root
		self.root.columnconfigure(0, weight=1)
		self.root.rowconfigure(0, weight=1)

		# +-root -----------------------------------------------+
		# | +- options_frame ----------+ +- progress_frame ---+ |
		# | |                          | |                   ^| |
		# | | ...                      | | (o) title_1 100%  || |
		# | |                          | | (o) title_2 50%   || |
		# | |                          | | (o) title_2 queue || |
		# | |                          | |                   || |
		# | |                          | |                   || |
		# | |                          | |                   || |
		# | |                          | |                   v| |
		# | +--------------------------+ +--------------------+ |
		# | +- buttons_frame ---------------------------------+ |
		# | | [Reset] [Help]                          [Start] | |
		# | +-------------------------------------------------- |
		# +-----------------------------------------------------+
		options_frame = ttk.Frame(self.root, padding=5, borderwidth=5, relief=tk.RAISED)
		self.progress_frame = ttk.Frame(self.root, padding=5, borderwidth=5, relief=tk.RAISED)
		buttons_frame = ttk.Frame(self.root, padding=5, borderwidth=5, relief=tk.RAISED)

		options_frame.columnconfigure(0, weight=1)
		options_frame.rowconfigure(1, weight=1)

		options_frame.grid(row=0, column=0, sticky=tk.E + tk.W + tk.N + tk.S)
		buttons_frame.grid(row=1, column=0, columnspan=2, sticky=tk.E + tk.W)
		self.progress_frame.grid(row=0, column=1, sticky=tk.E + tk.W + tk.N + tk.S)


		### progress_frame
		ttk.Label(self.progress_frame, text='Voeg een video toe om te beginnen'
		).grid(row=0, column=0, sticky=tk.N)


		### options_frame
		self.row = -1
		def row(inc=True):
			if inc: self.row += 1
			return self.row

		def label(text, add_space=True):
			if add_space:
				ttk.Label(options_frame, text='').grid(row=row(), column=0, pady=0)
			ttk.Label(options_frame, text=text).grid(row=row(), column=0, columnspan=3, sticky=tk.W)

		# url_input
		label("URL('s) naar afleveringpagina, meerdere URL's scheiden door witruimte (spaties of enter)", False)
		self.url_input = tk.Text(options_frame, height=3)
		self.url_input.grid(row=row(), column=0, sticky=tk.W + tk.E + tk.N + tk.S, columnspan=3)
		self.url_input.insert(tk.END, '\n'.join(argv_videos))

		# outdir
		self.outdir = tk.StringVar()
		self.outdir.set(os.path.expanduser('~'))
		outdir_input = tk.Entry(options_frame, textvariable=self.outdir)

		cmd = lambda: self.outdir.set(filedialog.askdirectory(
			initialdir=self.outdir.get(),
			parent=self.root,
			title='Selecteer map om bestanden op te slaan'
		))
		selectdir_btn = tk.Button(options_frame, text='Selecteer', command=cmd)

		label('Map om bestanden op te slaan')
		outdir_input.grid(row=row(), column=0, columnspan=2, sticky=tk.W + tk.E)
		selectdir_btn.grid(row=row(False), column=2, sticky=tk.E)

		# Filename
		ttk.Label(options_frame, text='').grid(row=row(), column=0, pady=0)
		r = row()
		# TODO: Fill in default; help link
		ttk.Label(options_frame, text='Bestandsnaam').grid(row=r, column=0, sticky=tk.W)
		self.filename = tk.Entry(options_frame)
		self.filename.grid(row=r, column=1, columnspan=2, sticky=tk.W + tk.E)

		# Quality
		self.quality = tk.IntVar()
		self.quality.set(2)

		r = row()
		ttk.Label(options_frame, text='Kwaliteit').grid(row=r, column=0, columnspan=2, sticky=tk.W)

		quality_frame = ttk.Frame(options_frame)
		quality_frame.grid(row=r, column=1, sticky=tk.W)

		quality1 = ttk.Radiobutton(quality_frame, text='Laag', variable=self.quality, value=0)
		quality2 = ttk.Radiobutton(quality_frame, text='Middel', variable=self.quality, value=1)
		quality3 = ttk.Radiobutton(quality_frame, text='Hoog', variable=self.quality, value=2)

		quality1.grid(row=0, column=1, sticky=tk.W)
		quality2.grid(row=0, column=2, sticky=tk.W)
		quality3.grid(row=0, column=3, sticky=tk.W)

		# Overwrite
		self.overwrite = tk.IntVar()
		overwrite = ttk.Checkbutton(options_frame, var=self.overwrite, text='Overschrijf al bestaande bestanden')
		overwrite.grid(row=row(), column=0, sticky=tk.W)

		# Subtitles
		self.subtitles = tk.IntVar()
		subtitles = ttk.Checkbutton(options_frame, var=self.subtitles, text='Download ook ondertiteling, als deze bestaat')
		subtitles.grid(row=row(), column=0, sticky=tk.W)

		### buttons_frame
		buttons_frame.columnconfigure(2, weight=1)

		reset_btn = ttk.Button(buttons_frame, text='Reset', command=self.click_reset)
		reset_btn.grid(row=0, column=0, sticky=tk.W)

		help_btn = ttk.Button(buttons_frame, text='Help', command=self.click_help)
		help_btn.grid(row=0, column=1, sticky=tk.W)

		start_btn = ttk.Button(buttons_frame, text='Voeg toe aan lijst', command=self.click_start)
		start_btn.grid(row=0, column=2, sticky=tk.E)

		self.root.minsize(width=600, height=300)
		self.root.update()

		v = dgemist.CheckUpdate()
		if v is not None:
			messagebox.showwarning('download-npo',
				'Waarschuwing: De laatste versie is %s, je gebruikt nu versie %s' % (
					v, dgemist.GetVersion()[0]))


	def click_reset(self):
		# TODO
		pass


	def click_help(self):
		messagebox.showinfo('download-npo',
			'Hop, wat help\n' +
			'Hop, wat help\n' +
			'Hop, wat help\n' +
			'Hop, wat help\n' +
			'asd asdfsafdfsaas safasf\n'
		)


	def click_start(self):
		v = self.url_input.get(1.0, tk.END).strip()
		if v == '' or self.outdir.get() == '': return

		self.urls = re.split('\s+', v)
		self.start_download()


	def start_download(self):
		for i, u in enumerate(self.urls):
			self.append_download_to_queue(u)
		self.run_queue()


	def make_progress_frame_entry(self, label_text, video):
		# +-------------------------------------------------+
		# | *Titel*                   start/pause] [cancel] |
		# | progress                                        |
		# +-------------------------------------------------+
		video['progress'] = tk.StringVar()
		video['progress'].set('Wachten...')

		frame = ttk.Frame(self.progress_frame, borderwidth=5, relief=tk.RAISED)
		frame.grid(row=video['row'], sticky=tk.W + tk.E + tk.N)

		title = tk.Label(frame, text=label_text)
		title.grid(row=0, column=0, sticky=tk.W)

		# TODO: Make the start/pause/cancel buttons
		#start = ttk.Button(frame, text='Start')
		#start.grid(row=0, column=1, sticky=tk.E)

		#cancel = ttk.Button(frame, text='Annuleren')
		#cancel.grid(row=0, column=2, sticky=tk.E)

		progress = tk.Label(frame, textvariable=video['progress'])
		progress.grid(row=1, column=0, sticky=tk.W)


	def append_download_to_queue(self, url):
		# Don't add the same video twice
		for v in self._videos:
			if v['url'] == url:
				return

		video = {
			'url': url,
			# 0: not yet started
			# 1: in progress
			# 2: finished
			# 3: error
			# 4: paused
			# 5: cancelled
			'status': 0,
		}
		self._videos.append(video)
		video['row'] = len(self._videos)

		def fetch_meta(video):
			try:
				site = dgemist.MatchSite(video['url'])
				videourl, playerId, ext = site.FindVideo(video['url'])
				meta = site.Meta(playerId)
				text = meta.get('title')
				self.queue.put(lambda: thread.start_new_thread(self.background_download, (video,)))
			except Exception as exc:
				text = '{} - Fout}'.format(url, sys.exc_info()[1])
			self.make_progress_frame_entry(text, video)
			thread.exit()
		self.queue.put(lambda: thread.start_new_thread(fetch_meta, (video,)))



	def run_queue(self):
		try:
			while True:
				self.queue.get_nowait()()
		except queue.Empty:
			pass
			#if self._downloading >= len(self.urls):
			#	self.urls = []

		self.root.after(100, self.run_queue)


	def background_download(self, video):
		""" Download videos in thread """

		print(video)
		#while self._downloading != i: time.sleep(1)

		site = dgemist.MatchSite(video['url'])
		try:
			videourl, playerId, ext = site.FindVideo(video['url'], self.quality.get())
			outdir = dgemist.ReplaceVars(self.outdir.get(), site.Meta(playerId))
			if not os.path.exists(outdir):
				try:
					os.makedirs(outdir)
				except OSErrror:
					Error("Output directory `{}' bestaat niet, en kan ook niet gemaakt worden ({})".format(
						outdir, sys.exc_info()[1]))
					sys.exit(1)
			if not os.path.isdir(outdir):
				Error("Output directory `%s' bestaat maar is geen directory" % outdir)
				sys.exit(1)

			outfile = dgemist.MakeFilename(outdir, self.filename.get(), ext, site.Meta(playerId), overwrite=self.overwrite.get())

			if self.subtitles.get() > 0:
				subout = dgemist.MakeFilename(outdir, self.filename.get(), 'srt', site.Meta(playerId), overwrite=self.overwrite.get())
				with open(subout, 'wb') as fp: fp.write(site.Subs(playerId).read())
		except dgemist.DgemistError:
			messagebox.showerror('Fout', sys.exc_info()[1])
			self.queue.put(lambda: video['progress'].set('Fout'))
			thread.exit()

		pcomplete = -1
		starttime = time.time()
		ptime = remaining = 0
		for total, completed, speed in site.DownloadVideo(videourl, outfile):
			completepc = int(completed / (total / 100))
			curtime = time.time()

			if completepc != pcomplete:
				#self.queue.put(lambda: video['progress'].set(completepc))
				pcomplete = completepc

			if curtime - starttime > 2:
				speed = int(completed / (curtime - starttime))
				if speed == 0:
					remaining = 100
				else:
					remaining = (total - completed) / speed

			if curtime >= ptime + 1:
				if speed == 0:
					remaining = 100
				else:
					remaining = (total - completed) / speed

				if total < 0:
					line = '  %(completed)s van onbekende groote met %(speed)4s/s' % ({
						'completed': dgemist.HumanSize(completed),
						'speed': dgemist.HumanSize(speed),
					})
				else:
					line = ('%(complete)3s%% van %(total)s; '
						+ 'nog %(remaining)4s te gaan met %(speed)4s/s') % ({
						'total': dgemist.HumanSize(total),
						'complete': completepc,
						'speed': dgemist.HumanSize(speed),
						'remaining': dgemist.HumanTime(remaining),
					})
				self.queue.put(lambda: video['progress'].set(line))
				ptime = curtime

		self.queue.put(lambda: video['progress'].set('Klaar'))
		thread.exit()


if __name__ == '__main__':
	root = tk.Tk()
	root.title('download-npo %s, %s (Esc om te sluiten)' %
		dgemist.GetVersion())
	root.bind('<Escape>', lambda ev: root.quit())

	s = ttk.Style()
	s.theme_use('clam')

	GUI(root, sys.argv[1:])

	try:
		root.mainloop()
	except KeyboardInterrupt:
		pass


# The MIT License (MIT)
#
# Copyright © 2012-2015 Martin Tournoij
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# The software is provided "as is", without warranty of any kind, express or
# implied, including but not limited to the warranties of merchantability,
# fitness for a particular purpose and noninfringement. In no event shall the
# authors or copyright holders be liable for any claim, damages or other
# liability, whether in an action of contract, tort or otherwise, arising
# from, out of or in connection with the software or the use or other dealings
# in the software.
